/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A collection of response builders.
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Debug = require('debug');
var debug = Debug('actions-on-google:debug');
var warn = Debug('actions-on-google:warn');
var error = Debug('actions-on-google:error');

var LIST_ITEM_LIMIT = 30;
var CAROUSEL_ITEM_LIMIT = 10;

/**
 * Simple Response type.
 * @typedef {Object} SimpleResponse
 * @property {string} speech - Speech to be spoken to user. SSML allowed.
 * @property {string} displayText - Optional text to be shown to user
 */

/**
 * Suggestions to show with response.
 * @typedef {Object} Suggestion
 * @property {string} title - Text of the suggestion.
 */

/**
 * Link Out Suggestion. Used in rich response as a suggestion chip which, when
 * selected, links out to external URL.
 * @typedef {Object} LinkOutSuggestion
 * @property {string} title - Text shown on the suggestion chip.
 * @property {string} url - String URL to open.
 */

/**
 * Image type shown on visual elements.
 * @typedef {Object} Image
 * @property {string} url - Image source URL.
 * @property {string} accessibilityText - Text to replace for image for
 *     accessibility.
 * @property {number} width - Width of the image.
 * @property {number} height - Height of the image.
 */

/**
 * Basic Card Button. Shown below basic cards. Open a URL when selected.
 * @typedef {Object} Button
 * @property {string} title - Text shown on the button.
 * @property {Object} openUrlAction - Action to take when selected.
 * @property {string} openUrlAction.url - String URL to open.
 */

/**
 * Option item. Used in actions.intent.OPTION intent.
 * @typedef {Object} OptionItem
 * @property {OptionInfo} optionInfo - Option item identifier information.
 * @property {string} title - Name of the item.
 * @property {string} description - Optional text describing the item.
 * @property {Image} image - Square image to show for this item.
 */

/**
 * Option info. Provides unique identifier for a given OptionItem.
 * @typedef {Object} OptionInfo
 * @property {string} key - Unique string ID for this option.
 * @property {Array<string>} synonyms - Synonyms that can be used by the user
 *     to indicate this option if they do not use the key.
 */

/**
 * Class for initializing and constructing Rich Responses with chainable interface.
 */
var RichResponse = function () {
  /**
   * Constructor for RichResponse. Accepts optional RichResponse to clone.
   *
   * @param {RichResponse} richResponse
   */
  function RichResponse(richResponse) {
    _classCallCheck(this, RichResponse);

    /**
     * Ordered list of either SimpleResponse objects or BasicCard objects.
     * First item must be SimpleResponse. There can be at most one card.
     * @type {Array<SimpleResponse|BasicCard>}
     */
    this.items = [];

    /**
     * Ordered list of text suggestions to display. Optional.
     * @type {Array<Suggestion>}
     */
    this.suggestions = [];

    /**
     * Link Out Suggestion chip for this rich response. Optional.
     * @type {LinkOutSuggestion}
     */
    this.linkOutSuggestion = undefined;

    if (richResponse) {
      if (richResponse.items) {
        this.items = richResponse.items;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            if (item.basicCard) {
              item.basicCard = new BasicCard(item.basicCard);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      if (richResponse.suggestions) {
        this.suggestions = richResponse.suggestions;
      }
      if (richResponse.linkOutSuggestion) {
        this.linkOutSuggestion = richResponse.linkOutSuggestion;
      }
    }
  }

  /**
   * Adds a SimpleResponse to list of items.
   *
   * @param {string|SimpleResponse} simpleResponse Simple response to present to
   *     user. If just a string, display text will not be set.
   * @return {RichResponse} Returns current constructed RichResponse.
   */


  _createClass(RichResponse, [{
    key: 'addSimpleResponse',
    value: function addSimpleResponse(simpleResponse) {
      if (!simpleResponse) {
        error('Invalid simpleResponse');
        return this;
      }
      // Validate if RichResponse already contains two SimpleResponse objects
      var simpleResponseCount = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          if (item.simpleResponse) {
            simpleResponseCount++;
          }
          if (simpleResponseCount >= 2) {
            error('Cannot include >2 SimpleResponses in RichResponse');
            return this;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var simpleResponseObj = {
        simpleResponse: this.buildSimpleResponseHelper_(simpleResponse)
      };
      // Check first if needs to replace BasicCard at beginning of items list
      if (this.items.length > 0 && (this.items[0].basicCard || this.items[0].structuredResponse)) {
        this.items.unshift(simpleResponseObj);
      } else {
        this.items.push(simpleResponseObj);
      }
      return this;
    }

    /**
     * Adds a BasicCard to list of items.
     *
     * @param {BasicCard} basicCard Basic card to include in response.
     * @return {RichResponse} Returns current constructed RichResponse.
     */

  }, {
    key: 'addBasicCard',
    value: function addBasicCard(basicCard) {
      if (!basicCard) {
        error('Invalid basicCard');
        return this;
      }
      // Validate if basic card is already present
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var item = _step3.value;

          if (item.basicCard) {
            error('Cannot include >1 BasicCard in RichResponse');
            return this;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.items.push({
        basicCard: basicCard
      });
      return this;
    }

    /**
     * Adds a single suggestion or list of suggestions to list of items.
     *
     * @param {string|Array<string>} suggestions Either a single string suggestion
     *     or list of suggestions to add.
     * @return {RichResponse} Returns current constructed RichResponse.
     */

  }, {
    key: 'addSuggestions',
    value: function addSuggestions(suggestions) {
      if (!suggestions) {
        error('Invalid suggestions');
        return this;
      }
      if (Array.isArray(suggestions)) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = suggestions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var suggestion = _step4.value;

            if (this.isValidSuggestionText(suggestion)) {
              this.suggestions.push({ title: suggestion });
            } else {
              warn('Suggestion text can\'t be longer than 25 characters: ' + suggestion + '. This suggestion won\'t be added to the list.');
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      } else {
        if (this.isValidSuggestionText(suggestions)) {
          this.suggestions.push({ title: suggestions });
        } else {
          warn('Suggestion text can\'t be longer than 25 characters: ' + suggestions + '. This suggestion won\'t be added to the list.');
        }
      }
      return this;
    }

    /**
     * Returns true if the given suggestion text is valid to be added to the suggestion list. A valid
     * text string is not longer than 25 characters.
     */

  }, {
    key: 'isValidSuggestionText',
    value: function isValidSuggestionText(suggestionText) {
      return suggestionText && suggestionText.length && suggestionText.length <= 25;
    }

    /**
     * Sets the suggestion link for this rich response.
     *
     * @param {string} destinationName Name of the link out destination.
     * @param {string} suggestionUrl - String URL to open when suggestion is used.
     * @return {RichResponse} Returns current constructed RichResponse.
     */

  }, {
    key: 'addSuggestionLink',
    value: function addSuggestionLink(destinationName, suggestionUrl) {
      if (!destinationName) {
        error('destinationName cannot be empty');
        return this;
      }
      if (!suggestionUrl) {
        error('suggestionUrl cannot be empty');
        return this;
      }
      this.linkOutSuggestion = {
        destinationName: destinationName,
        url: suggestionUrl
      };
      return this;
    }

    /**
     * Adds an order update to this response. Use after a successful transaction
     * decision to confirm the order.
     *
     * @param {OrderUpdate} orderUpdate
     * @return {RichResponse} Returns current constructed RichResponse.
     */

  }, {
    key: 'addOrderUpdate',
    value: function addOrderUpdate(orderUpdate) {
      if (!orderUpdate) {
        error('Invalid orderUpdate');
        return this;
      }
      // Validate if RichResponse already contains StructuredResponse object
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.items[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var item = _step5.value;

          if (item.structuredResponse) {
            debug('Cannot include >1 StructuredResponses in RichResponse');
            return this;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this.items.push({
        structuredResponse: {
          orderUpdate: orderUpdate
        }
      });
      return this;
    }

    /**
     * Helper to build SimpleResponse from speech and display text.
     *
     * @param {string|SimpleResponse} response String to speak, or SimpleResponse.
     *     SSML allowed.
     * @param {string} response.speech If using SimpleResponse, speech to be spoken
     *     to user.
     * @param {string=} response.displayText If using SimpleResponse, text to be shown
     *     to user.
     * @return {Object} Appropriate SimpleResponse object.
     * @private
     */

  }, {
    key: 'buildSimpleResponseHelper_',
    value: function buildSimpleResponseHelper_(response) {
      if (!response) {
        error('Invalid response');
        return null;
      }
      debug('buildSimpleResponseHelper_: response=%s', JSON.stringify(response));
      var simpleResponseObj = {};
      if (typeof response === 'string') {
        simpleResponseObj = isSsml(response) ? { ssml: response } : { textToSpeech: response };
      } else if (response.speech) {
        simpleResponseObj = isSsml(response.speech) ? { ssml: response.speech } : { textToSpeech: response.speech };
        simpleResponseObj.displayText = response.displayText;
      } else {
        error('SimpleResponse requires a speech parameter.');
        return null;
      }
      return simpleResponseObj;
    }
  }]);

  return RichResponse;
}();

/**
 * Class for initializing and constructing Basic Cards with chainable interface.
 */
var BasicCard = function () {
  /**
   * Constructor for BasicCard. Accepts optional BasicCard to clone.
   *
   * @param {BasicCard} basicCard
   */
  function BasicCard(basicCard) {
    _classCallCheck(this, BasicCard);

    /**
     * Title of the card. Optional.
     * @type {string}
     */
    this.title = undefined;

    /**
     * Body text to show on the card. Required, unless image is present.
     * @type {string}
     */
    this.formattedText = '';

    /**
     * Subtitle of the card. Optional.
     * @type {string}
     */
    this.subtitle = undefined;

    /**
     * Image to show on the card. Optional.
     * @type {Image}
     */
    this.image = undefined;

    /**
     * Ordered list of buttons to show below card. Optional.
     * @type {Array<Button>}
     */
    this.buttons = [];

    if (basicCard) {
      if (basicCard.formattedText) {
        this.formattedText = basicCard.formattedText;
      }
      if (basicCard.buttons) {
        this.buttons = basicCard.buttons;
      }
      if (basicCard.title) {
        this.title = basicCard.title;
      }
      if (basicCard.subtitle) {
        this.subtitle = basicCard.subtitle;
      }
      if (basicCard.image) {
        this.image = basicCard.image;
      }
    }
  }

  /**
   * Sets the title for this Basic Card.
   *
   * @param {string} title Title to show on card.
   * @return {BasicCard} Returns current constructed BasicCard.
   */


  _createClass(BasicCard, [{
    key: 'setTitle',
    value: function setTitle(title) {
      if (!title) {
        error('title cannot be empty');
        return this;
      }
      this.title = title;
      return this;
    }

    /**
     * Sets the subtitle for this Basic Card.
     *
     * @param {string} subtitle Subtitle to show on card.
     * @return {BasicCard} Returns current constructed BasicCard.
     */

  }, {
    key: 'setSubtitle',
    value: function setSubtitle(subtitle) {
      if (!subtitle) {
        error('subtitle cannot be empty');
        return this;
      }
      this.subtitle = subtitle;
      return this;
    }

    /**
     * Sets the body text for this Basic Card.
     *
     * @param {string} bodyText Body text to show on card.
     * @return {BasicCard} Returns current constructed BasicCard.
     */

  }, {
    key: 'setBodyText',
    value: function setBodyText(bodyText) {
      if (!bodyText) {
        error('bodyText cannot be empty');
        return this;
      }
      this.formattedText = bodyText;
      return this;
    }

    /**
     * Sets the image for this Basic Card.
     *
     * @param {string} url Image source URL.
     * @param {string} accessibilityText Text to replace for image for
     *     accessibility.
     * @param {number=} width Width of the image.
     * @param {number=} height Height of the image.
     * @return {BasicCard} Returns current constructed BasicCard.
     */

  }, {
    key: 'setImage',
    value: function setImage(url, accessibilityText, width, height) {
      if (!url) {
        error('url cannot be empty');
        return this;
      }
      if (!accessibilityText) {
        error('accessibilityText cannot be empty');
        return this;
      }
      this.image = { url: url, accessibilityText: accessibilityText };
      if (width) {
        this.image.width = width;
      }
      if (height) {
        this.image.height = height;
      }
      return this;
    }

    /**
     * Adds a button below card.
     *
     * @param {string} text Text to show on button.
     * @param {string} url URL to open when button is selected.
     * @return {BasicCard} Returns current constructed BasicCard.
     */

  }, {
    key: 'addButton',
    value: function addButton(text, url) {
      if (!text) {
        error('text cannot be empty');
        return this;
      }
      if (!url) {
        error('url cannot be empty');
        return this;
      }
      this.buttons.push({
        title: text,
        openUrlAction: {
          url: url
        }
      });
      return this;
    }
  }]);

  return BasicCard;
}();

/**
 * Class for initializing and constructing Lists with chainable interface.
 */
var List = function () {
  /**
   * Constructor for List. Accepts optional List to clone, string title, or
   * list of items to copy.
   *
   * @param {List|string|Array<OptionItem>} list Either a list to clone, a title
   *     to set for a new List, or an array of OptionItem to initialize a new
   *     list.
   */
  function List(list) {
    _classCallCheck(this, List);

    /**
     * Title of the list. Optional.
     * @type {string}
     */
    this.title = undefined;

    /**
     * List of 2-20 items to show in this list. Required.
     * @type {Array<OptionItems>}
     */
    this.items = [];

    if (list) {
      if (typeof list === 'string') {
        this.title = list;
      } else if (Array.isArray(list)) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = list[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var item = _step6.value;

            this.items.push(new OptionItem(item));
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      } else if ((typeof list === 'undefined' ? 'undefined' : _typeof(list)) === 'object') {
        if (list.title) {
          this.title = list.title;
        }
        if (list.items) {
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = list.items[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var _item = _step7.value;

              this.items.push(new OptionItem(_item));
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        }
      }
    }
  }

  /**
   * Sets the title for this List.
   *
   * @param {string} title Title to show on list.
   * @return {List} Returns current constructed List.
   */


  _createClass(List, [{
    key: 'setTitle',
    value: function setTitle(title) {
      if (!title) {
        error('title cannot be empty');
        return this;
      }
      this.title = title;
      return this;
    }

    /**
     * Adds a single item or list of items to the list.
     *
     * @param {OptionItem|Array<OptionItem>} optionItems OptionItems to add.
     * @return {List} Returns current constructed List.
     */

  }, {
    key: 'addItems',
    value: function addItems(optionItems) {
      if (!optionItems) {
        error('optionItems cannot be null');
        return this;
      }
      if (Array.isArray(optionItems)) {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = optionItems[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var item = _step8.value;

            this.items.push(item);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      } else {
        this.items.push(optionItems);
      }
      if (this.items.length > LIST_ITEM_LIMIT) {
        this.items = this.items.slice(0, LIST_ITEM_LIMIT);
        error('Carousel can have no more than ' + LIST_ITEM_LIMIT + ' items');
      }
      return this;
    }
  }]);

  return List;
}();

/**
 * Class for initializing and constructing Carousel with chainable interface.
 */
var Carousel = function () {
  /**
   * Constructor for Carousel. Accepts optional Carousel to clone or list of
   * items to copy.
   *
   * @param {Carousel|Array<OptionItem>} carousel Either a carousel to clone, a
   *     or an array of OptionItem to initialize a new carousel
   */
  function Carousel(carousel) {
    _classCallCheck(this, Carousel);

    /**
     * List of 2-20 items to show in this carousel. Required.
     * @type {Array<OptionItems>}
     */
    this.items = [];

    if (carousel) {
      if (Array.isArray(carousel)) {
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = carousel[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var item = _step9.value;

            this.items.push(new OptionItem(item));
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      } else if ((typeof carousel === 'undefined' ? 'undefined' : _typeof(carousel)) === 'object') {
        if (carousel.items) {
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = undefined;

          try {
            for (var _iterator10 = carousel.items[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var _item2 = _step10.value;

              this.items.push(new OptionItem(_item2));
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10.return) {
                _iterator10.return();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }
        }
      }
    }
  }

  /**
   * Adds a single item or list of items to the carousel.
   *
   * @param {OptionItem|Array<OptionItem>} optionItems OptionItems to add.
   * @return {Carousel} Returns current constructed Carousel.
   */


  _createClass(Carousel, [{
    key: 'addItems',
    value: function addItems(optionItems) {
      if (!optionItems) {
        error('optionItems cannot be null');
        return this;
      }
      if (Array.isArray(optionItems)) {
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = optionItems[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var item = _step11.value;

            this.items.push(item);
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      } else {
        this.items.push(optionItems);
      }
      if (this.items.length > CAROUSEL_ITEM_LIMIT) {
        this.items = this.items.slice(0, CAROUSEL_ITEM_LIMIT);
        error('Carousel can have no more than ' + CAROUSEL_ITEM_LIMIT + ' items');
      }
      return this;
    }
  }]);

  return Carousel;
}();

/**
 * Class for initializing and constructing Option Items with chainable interface.
 */
var OptionItem = function () {
  /**
   * Constructor for OptionItem. Accepts optional OptionItem to clone.
   *
   * @param {OptionItem} optionItem
   */
  function OptionItem(optionItem) {
    _classCallCheck(this, OptionItem);

    /**
     * Option info of the option item. Required.
     * @type {OptionInfo}
     */
    this.optionInfo = {
      key: '',
      synonyms: []
    };

    /**
     * Title of the option item. Required.
     * @type {string}
     */
    this.title = '';

    /**
     * Description text of the item. Optional.
     * @type {string}
     */
    this.description = undefined;

    /**
     * Image to show on item. Optional.
     * @type {Image}
     */
    this.image = undefined;

    if (optionItem) {
      if (optionItem.optionInfo) {
        if (optionItem.optionInfo.key) {
          this.optionInfo.key = optionItem.optionInfo.key;
        }
        if (optionItem.optionInfo.synonyms) {
          this.optionInfo.synonyms = optionItem.optionInfo.synonyms;
        }
      }
      if (optionItem.title) {
        this.title = optionItem.title;
      }
      if (optionItem.description) {
        this.description = optionItem.description;
      }
      if (optionItem.image) {
        this.image = optionItem.image;
      }
    }
  }

  /**
   * Sets the title for this Option Item.
   *
   * @param {string} title Title to show on item.
   * @return {OptionItem} Returns current constructed OptionItem.
   */


  _createClass(OptionItem, [{
    key: 'setTitle',
    value: function setTitle(title) {
      if (!title) {
        error('title cannot be empty');
        return this;
      }
      this.title = title;
      return this;
    }

    /**
     * Sets the description for this Option Item.
     *
     * @param {string} description Description to show on item.
     * @return {OptionItem} Returns current constructed OptionItem.
     */

  }, {
    key: 'setDescription',
    value: function setDescription(description) {
      if (!description) {
        error('descriptions cannot be empty');
        return this;
      }
      this.description = description;
      return this;
    }

    /**
     * Sets the image for this Option Item.
     *
     * @param {string} url Image source URL.
     * @param {string} accessibilityText Text to replace for image for
     *     accessibility.
     * @param {number=} width Width of the image.
     * @param {number=} height Height of the image.
     * @return {OptionItem} Returns current constructed OptionItem.
     */

  }, {
    key: 'setImage',
    value: function setImage(url, accessibilityText, width, height) {
      if (!url) {
        error('url cannot be empty');
        return this;
      }
      if (!accessibilityText) {
        error('accessibilityText cannot be empty');
        return this;
      }
      this.image = { url: url, accessibilityText: accessibilityText };
      if (width) {
        this.image.width = width;
      }
      if (height) {
        this.image.height = height;
      }
      return this;
    }

    /**
     * Sets the key for the OptionInfo of this Option Item. This will be returned
     * as an argument in the resulting actions.intent.OPTION intent.
     *
     * @param {string} key Key to uniquely identify this item.
     * @return {OptionItem} Returns current constructed OptionItem.
     */

  }, {
    key: 'setKey',
    value: function setKey(key) {
      if (!key) {
        error('key cannot be empty');
        return this;
      }
      this.optionInfo.key = key;
      return this;
    }

    /**
     * Adds a single synonym or list of synonyms to item.
     *
     * @param {string|Array<string>} synonyms Either a single string synonyms
     *     or list of synonyms to add.
     * @return {OptionItem} Returns current constructed OptionItem.
     */

  }, {
    key: 'addSynonyms',
    value: function addSynonyms(synonyms) {
      if (!synonyms) {
        error('Invalid synonyms');
        return this;
      }
      if (Array.isArray(synonyms)) {
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = synonyms[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var synonym = _step12.value;

            this.optionInfo.synonyms.push(synonym);
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12.return) {
              _iterator12.return();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }
      } else {
        this.optionInfo.synonyms.push(synonyms);
      }
      return this;
    }
  }]);

  return OptionItem;
}();

function isSsml(text) {
  return (/^<speak\b[^>]*>([^]*?)<\/speak>$/gi.test(text)
  );
}

module.exports = {
  RichResponse: RichResponse,
  BasicCard: BasicCard,
  List: List,
  Carousel: Carousel,
  OptionItem: OptionItem,
  isSsml: isSsml
};