/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

// Enable actions-on-google debug logging

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

process.env.DEBUG = 'actions-on-google:*';

// lodash helpers
var camelCase = require('lodash.camelcase');
var snakeCase = require('lodash.snakecase');

/**
 * Transforms incoming object to new camelCase-keyed object.
 *
 * @example
 * const snakeCaseObject = {
 *   key_one: {
 *     key_two: [
 *       {
 *         key: 'value'
 *       },
 *       'array_item_two'
 *     ]
 *   }
 * };
 * let camelCaseObject = transformToCamelCase(snakeCaseObject);
 * // camelCaseObject === {
 * //   keyOne: {
 * //     keyTwo: [
 * //       {
 * //         key: 'value'
 * //       },
 * //       'array_item_two'
 * //     ]
 * //   }
 * // };
 *
 * @param {Object} object Object to transform.
 * @return {Object} Incoming object deeply mapped to camelCase keys.
 */
function transformToCamelCase(object) {
  return transform(object, camelCase);
}

/**
 * Transforms incoming object to new snake_case-keyed object.
 *
 * @example
 * const camelCaseObject = {
 *   keyOne: {
 *     keyTwo: [
 *       {
 *         key: 'value'
 *       },
 *       'arrayItemTwo'
 *     ]
 *   }
 * };
 * let snakeCaseObject = transformToSnakeCase(camelCaseObject);
 * // snakeCaseObject === {
 * //   key_one: {
 * //     key_two: [
 * //       {
 * //         key: 'value'
 * //       },
 * //       'arrayItemTwo'
 * //     ]
 * //   }
 * // };
 *
 * @param {Object} object Object to transform.
 * @return {Object} Incoming object deeply mapped to camelCase keys.
 */
function transformToSnakeCase(object) {
  return transform(object, snakeCase);
}

/**
 * Generic deep object transformation utility. Recursively converts all object
 * keys, including those of array elements, with some transformation function.
 * Note that classes will get converted to objects.
 *
 * @param {Object} object Object to transform.
 * @param {Function} keyTransformation
 */
function transform(object, keyTransformation) {
  var newObject = object;
  if (Array.isArray(object)) {
    newObject = object.map(function (element) {
      return transform(element, keyTransformation);
    });
  } else if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object') {
    newObject = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(object)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        var transformedKey = keyTransformation(key);
        newObject[transformedKey] = transform(object[key], keyTransformation);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  return newObject;
}

module.exports = {
  transformToCamelCase: transformToCamelCase,
  transformToSnakeCase: transformToSnakeCase
};